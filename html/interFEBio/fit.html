<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>interFEBio.fit API documentation</title>
<meta name="description" content="This module allows to execute flexible fitting procedures, with full control
of the fitting method, variables, calculations and experimental data â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>interFEBio.fit</code></h1>
</header>
<section id="section-intro">
<p>This module allows to execute flexible fitting procedures, with full control
of the fitting method, variables, calculations and experimental data formats.</p>
<h1 id="todo">TODO</h1>
<ul>
<li>LMFIT library works on serial numerical approximations to obtain a jacobian,
however, when the residual function is time expensive, the fitting process
is too long. A parallel jacobian calculation is implemented, but it is quite rudimental,
so is disabled in the source code by now.</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module allows to execute flexible fitting procedures, with full control
of the fitting method, variables, calculations and experimental data formats.

# TODO

- LMFIT library works on serial numerical approximations to obtain a jacobian,
     however, when the residual function is time expensive, the fitting process
     is too long. A parallel jacobian calculation is implemented, but it is quite rudimental,
     so is disabled in the source code by now.


&#34;&#34;&#34;

import numpy as np
import lmfit
from scipy.interpolate import interp1d
import xml.etree.ElementTree as ET
import os
import subprocess
import threading
import sys
import time
from datetime import datetime
import psutil
from sklearn.metrics import r2_score
import interFEBio
from scipy.ndimage import interpolation
import signal


class _caso:

    def __init__(self,modelName,matID,subFolder,expData,simFcn):

        self.modelName = modelName
        self.modelBinary = modelName.split(&#39;.feb&#39;)[0]+&#39;.xplt&#39;
        self.matID = matID
        self.subFolder = subFolder
        self.expData = expData
        self.current_directory = os.getcwd()
        self.simFcn = simFcn
        self.parameters = []

    def addParameter(self,param):
        self.parameters.append(param)

    def writeCase(self,params,iter):
        pars = dict(params.valuesdict())
        originalTree = ET.parse(self.modelName)
        tree = originalTree
        root = tree.getroot()
        for material in root.findall(&#39;.//material&#39;):
            if(material.attrib[&#39;id&#39;] == str(self.matID) or material.attrib[&#39;name&#39;] == str(self.matID)):
                for const in material:
                    #print(const.tag, self.parameters)
                    if(const.tag in self.parameters):
                        #print(pars[const.tag])
                        const.text = &#39;{:.20e}&#39;.format(pars[const.tag])
                        #print(const.tag,const.text)
        #print(os.path.join(self.current_directory, &#39;iter&#39;+str(iter),self.subFolder))
        tree.write(os.path.join(self.current_directory, &#39;iter&#39;+str(iter),self.subFolder)+&#39;/&#39;+self.modelName,encoding=&#39;ISO-8859-1&#39;, xml_declaration=True)

        # for p in pars.keys():
        #     if params[p].expr == None:
        #         tree = originalTree
        #         root = tree.getroot()
        #         for material in root.findall(&#39;.//material&#39;):
        #             if(material.attrib[&#39;id&#39;] == str(self.matID)):
        #                 for const in material:
        #                     #print(const.tag, self.parameters)
        #                     if(const.tag in self.parameters and const.tag == p):
        #                         #print(pars[const.tag])
        #                         const.text = &#39;{:.20e}&#39;.format(pars[const.tag]*(1+0.05)/1000.0)
        #                     if(const.tag in self.parameters and const.tag != p):
        #                         const.text = &#39;{:.20e}&#39;.format(pars[const.tag]/1000.0)
        #                         #print(const.tag,const.text)
        #         #print(os.path.join(self.current_directory, &#39;iter&#39;+str(iter),self.subFolder))
        #         tree.write(os.path.join(self.current_directory, &#39;iter&#39;+str(iter),self.subFolder,p)+&#39;/&#39;+self.modelName.split(&#39;.&#39;)[0]+&#39;_&#39;+p+&#34;.feb&#34;,encoding=&#39;ISO-8859-1&#39;, xml_declaration=True)

    def verifyFolders(self,iter,p):
        pars = dict(p.valuesdict())
        iterDir = os.path.join(self.current_directory, &#39;iter&#39;+str(iter))
        if not os.path.exists(iterDir):
            os.makedirs(iterDir)
        simDir = os.path.join(iterDir, self.subFolder)
        if not os.path.exists(simDir):
            os.makedirs(simDir)
        # for par in pars.keys():
        #     if p[par].expr == None:
        #         paramPath = os.path.join(simDir, par)
        #         if not os.path.exists(paramPath):
        #             os.makedirs(paramPath)

    # def simToFunctions(self,iter,parameter):
    #     param = parameter.keys()
    #     stretch,stress = self.rawResults(iter,&#39;&#39;)
    #     funSim = dict()
    #     funSim[&#39;fx&#39;] = interp1d(stretch, stress,fill_value=&#39;extrapolate&#39;)
    #     for p in param:
    #         if parameter[p].expr == None:
    #             stretch,stress = self.rawResults(iter,p)
    #             funSim[p] = interp1d(stretch, stress,fill_value=&#39;extrapolate&#39;)
    #
    #     return funSim
    #
    # def singleSimToFunction(self,iter):
    #     stretch,stress = self.rawResults(iter,&#39;&#39;)
    #     funSim = interp1d(stretch, stress,fill_value=&#39;extrapolate&#39;)
    #     return funSim

    def simResults(self,iter):
        file = &#39;iter&#39;+str(iter)+&#39;/&#39;+self.subFolder+&#39;/&#39;+self.modelBinary
        x, y = self.simFcn(self,file)
        np.savetxt(os.path.join(self.current_directory, &#39;iter&#39;+str(iter),self.subFolder)+&#39;/result.txt&#39;,np.transpose([x, y]))
        return x, y


class fit:
    &#39;&#39;&#39;
    Class that handles the numerical fitting algotirm.
    This class is based on lmfit library.

    &#39;&#39;&#39;
    def __init__(self):
        self.iter = 1
        self.p = lmfit.Parameters()
        self.mi = 0 #Used for saving fit results
        now = datetime.now()
        current_time = now.strftime(&#34;%H:%M:%S&#34;)
        current_date = datetime.today().strftime(&#39;%d-%m-%Y&#39;)
        self.logfileName = &#39;log_&#39;+current_date+&#39;_&#39;+current_time+&#39;.txt&#39;
        self.len1 = dict()
        signal.signal(signal.SIGINT, self._signal_handler)
        self.pid = dict()

        self.casos = dict()
        self.exp = dict()
        self.done = 0
        self.thisIter = 0
        self.disp1 = dict()

    def addCase(self,name,matID,modelName,subFolder,expData,simFcn):
        &#39;&#39;&#39;
        Add a simulation to the fitting algorithm, including all the experimental data
        and how to obtain numerical results for this xplt file.

        Args:
        ----------

            modelName (str): Name of the .feb model

            matID (int/str): id/name of the material to be fitted in that particular .feb file

            subFolder (str): Sub folder to store the simulation at each iteration.

            expData (np array): Array of x,y experimental data associated with the current simulation.

            simFcn (fuinction): Function that handles the result calculation of the simulation. Needs to be written in terms of the xplt class functions.

        &#39;&#39;&#39;
        self.casos[name] = _caso(modelName,matID,subFolder,expData,simFcn)

    def _updateParamList(self):
        #os.environ[&#39;OMP_NUM_THR        # for par in pars.keys():
        #     if p[par].expr == None:
        #         paramPath = os.path.join(simDir, par)
        #         if not os.path.exists(paramPath):
        #             os.makedirs(paramPath)EADS&#39;] = str(round(psutil.cpu_count()/2/(len(self.p.valuesdict())-1)))
        self.parVals = self.p.valuesdict()
        for key in self.parVals.keys():
            for caso in self.casos:
                self.casos[caso].addParameter(key)

    def _run(self,caso,dh):

        if(dh == &#39;&#39;):
            p = subprocess.Popen([&#34;febio3 -i &#34;+self.casos[caso].modelName],shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT,cwd=os.path.join(&#39;iter&#39;+str(self.iter),self.casos[caso].subFolder)+&#39;/&#39;)
            print(&#34;Running simulation &#34;+os.path.join(&#39;iter&#39;+str(self.iter),self.casos[caso].subFolder)+&#39;/&#39;+self.casos[caso].modelName+ &#34;. PID: &#34;,p.pid)
        else:
            p = subprocess.Popen([&#34;febio3 -i &#34;+self.casos[caso].modelName.split(&#39;.&#39;)[0]+&#39;_&#39;+dh+&#39;.feb&#39;],shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT,cwd=os.path.join(&#39;iter&#39;+str(self.iter),self.casos[caso].subFolder,dh)+&#39;/&#39;)
            print(&#34;Running simulation &#34;+os.path.join(&#39;iter&#39;+str(self.iter),self.casos[caso].subFolder)+&#39;/&#39;+self.casos[caso].modelName.split(&#39;.&#39;)[0]+&#39;_&#39;+dh+&#39;.feb&#39;+ &#34;. PID: &#34;,p.pid)
        self.pid[caso] = p.pid
        p.communicate()
        p.wait()
        #sys.exit()

    def _expToFunction(self):
        self.expfcn = dict()
        for caso in self.casos:
            self.expfcn[caso] = interp1d(self.casos[caso].expData[:,0], self.casos[caso].expData[:,1],fill_value=&#39;extrapolate&#39;)

    def _statistics(self,p):
        parameters = dict(p.valuesdict())
        self.r2 = dict()
        for case in self.casos:
            actual = self.expfcn[case](self.results[case][0])
            predict = self.results[case][1]

            R_sq = r2_score(actual, predict)
            self.r2[case] = R_sq

        self.logfile = open(self.logfileName, &#39;a&#39;)
        self.logfile.write(&#39;iter &#39;+str(self.iter)+&#39;\t&#39;)
        self.logfile.write(datetime.now().strftime(&#34;%H:%M:%S&#34;)+&#39;:\n&#39;)
        self.logfile.write(&#39;\t&#39;+&#39;r2 = &#39;)
        self.logfile.write(str(self.r2))
        self.logfile.write(&#39;\n&#39;)
        self.logfile.write(&#39;\t&#39;+&#39;Parameters = &#39;)
        self.logfile.write(str(parameters))
        self.logfile.write(&#39;\n&#39;)
        self.logfile.close()


    def _residual(self,p):
        parameter = dict(p.valuesdict())
        for caso in self.casos:
            self.casos[caso].verifyFolders(self.iter,p)
            self.casos[caso].writeCase(p,self.iter)
        #if(self.thisIter != self.iter):
        z = []
        for caso in self.casos:
            t = threading.Thread(target=self._run, args=(caso,&#39;&#39;))
            t.start()
            z.append(t)
        for t in z:
           t.join()

        # #sys.exit()
        fun = dict()
        residual = dict()
        self._expToFunction()
        self.results = dict()
        totResid = []

        totResid = np.array([])
        for caso in self.casos:
            x, y = self.casos[caso].simResults(self.iter)
            if(self.iter == 1):
                self.len1[caso] = len(x)

            else:
                if(len(x) != self.len1[caso]):
                    i = self.len1[caso]
                    z = i / len(x)
                    x = interpolation.zoom(x,z)
                    y = interpolation.zoom(y,z)
            residual[caso] = -(self.expfcn[caso](x)-y)
            self.results[caso] = [x,y]
            #self.residual = residual
            #totResid.append(residual[caso])
            totResid = np.append(totResid,residual[caso])
        self._statistics(p)
        return totResid

    def _per_iteration(self,pars, iter, resid, *args, **kws):
        print(&#34; ITER &#34;, iter, [[i,pars.valuesdict()[i]] for i in pars.valuesdict()])
        self.iter = iter+3

    def optimize(self,**kwargs):
        &#39;&#39;&#39;
        Optimize.

        This function start the optimization algorithm.
        The residual is calculated from the simulation (using the external function provided for the case), and compare those results with the experimental data provided.


        kwargs:
        ----------

            kwargs for the lmfit.minimize function.
            &gt;&gt;&gt; optimize(method=&#39;basinhopping&#39;)
        &#39;&#39;&#39;
        self._updateParamList()
        self.mi = lmfit.minimize(self._residual,
                            self.p,
                            **dict(kwargs, iter_cb=self._per_iteration)
                            )
        lmfit.printfuncs.report_fit(self.mi.params, min_correl=0.5)
        print(lmfit.fit_report(self.mi))

    def _signal_handler(self,sig, frame):
        print()
        print(&#34;***********************************&#34;)
        print(&#34;***********************************&#34;)
        print()
        print(&#39;You pressed Ctrl+C!&#39;)
        print(&#34;Killing the running simulations:&#34;)
        print(self.pid)
        print()
        print(&#34;***********************************&#34;)
        print(&#34;***********************************&#34;)

        for key in self.pid:
            try:
                parent = psutil.Process(self.pid[key])
            except:
                continue
            for child in parent.children(recursive=True):  # or parent.children() for recursive=False
                try:
                    child.kill()
                except:
                    print(&#34;Child process no longer exists.&#34;)
                    continue
            try:
                parent.kill()
            except:
                print(&#34;Parent process no longer exists.&#34;)
                continue
        sys.exit(0)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="interFEBio.fit.fit"><code class="flex name class">
<span>class <span class="ident">fit</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class that handles the numerical fitting algotirm.
This class is based on lmfit library.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class fit:
    &#39;&#39;&#39;
    Class that handles the numerical fitting algotirm.
    This class is based on lmfit library.

    &#39;&#39;&#39;
    def __init__(self):
        self.iter = 1
        self.p = lmfit.Parameters()
        self.mi = 0 #Used for saving fit results
        now = datetime.now()
        current_time = now.strftime(&#34;%H:%M:%S&#34;)
        current_date = datetime.today().strftime(&#39;%d-%m-%Y&#39;)
        self.logfileName = &#39;log_&#39;+current_date+&#39;_&#39;+current_time+&#39;.txt&#39;
        self.len1 = dict()
        signal.signal(signal.SIGINT, self._signal_handler)
        self.pid = dict()

        self.casos = dict()
        self.exp = dict()
        self.done = 0
        self.thisIter = 0
        self.disp1 = dict()

    def addCase(self,name,matID,modelName,subFolder,expData,simFcn):
        &#39;&#39;&#39;
        Add a simulation to the fitting algorithm, including all the experimental data
        and how to obtain numerical results for this xplt file.

        Args:
        ----------

            modelName (str): Name of the .feb model

            matID (int/str): id/name of the material to be fitted in that particular .feb file

            subFolder (str): Sub folder to store the simulation at each iteration.

            expData (np array): Array of x,y experimental data associated with the current simulation.

            simFcn (fuinction): Function that handles the result calculation of the simulation. Needs to be written in terms of the xplt class functions.

        &#39;&#39;&#39;
        self.casos[name] = _caso(modelName,matID,subFolder,expData,simFcn)

    def _updateParamList(self):
        #os.environ[&#39;OMP_NUM_THR        # for par in pars.keys():
        #     if p[par].expr == None:
        #         paramPath = os.path.join(simDir, par)
        #         if not os.path.exists(paramPath):
        #             os.makedirs(paramPath)EADS&#39;] = str(round(psutil.cpu_count()/2/(len(self.p.valuesdict())-1)))
        self.parVals = self.p.valuesdict()
        for key in self.parVals.keys():
            for caso in self.casos:
                self.casos[caso].addParameter(key)

    def _run(self,caso,dh):

        if(dh == &#39;&#39;):
            p = subprocess.Popen([&#34;febio3 -i &#34;+self.casos[caso].modelName],shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT,cwd=os.path.join(&#39;iter&#39;+str(self.iter),self.casos[caso].subFolder)+&#39;/&#39;)
            print(&#34;Running simulation &#34;+os.path.join(&#39;iter&#39;+str(self.iter),self.casos[caso].subFolder)+&#39;/&#39;+self.casos[caso].modelName+ &#34;. PID: &#34;,p.pid)
        else:
            p = subprocess.Popen([&#34;febio3 -i &#34;+self.casos[caso].modelName.split(&#39;.&#39;)[0]+&#39;_&#39;+dh+&#39;.feb&#39;],shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT,cwd=os.path.join(&#39;iter&#39;+str(self.iter),self.casos[caso].subFolder,dh)+&#39;/&#39;)
            print(&#34;Running simulation &#34;+os.path.join(&#39;iter&#39;+str(self.iter),self.casos[caso].subFolder)+&#39;/&#39;+self.casos[caso].modelName.split(&#39;.&#39;)[0]+&#39;_&#39;+dh+&#39;.feb&#39;+ &#34;. PID: &#34;,p.pid)
        self.pid[caso] = p.pid
        p.communicate()
        p.wait()
        #sys.exit()

    def _expToFunction(self):
        self.expfcn = dict()
        for caso in self.casos:
            self.expfcn[caso] = interp1d(self.casos[caso].expData[:,0], self.casos[caso].expData[:,1],fill_value=&#39;extrapolate&#39;)

    def _statistics(self,p):
        parameters = dict(p.valuesdict())
        self.r2 = dict()
        for case in self.casos:
            actual = self.expfcn[case](self.results[case][0])
            predict = self.results[case][1]

            R_sq = r2_score(actual, predict)
            self.r2[case] = R_sq

        self.logfile = open(self.logfileName, &#39;a&#39;)
        self.logfile.write(&#39;iter &#39;+str(self.iter)+&#39;\t&#39;)
        self.logfile.write(datetime.now().strftime(&#34;%H:%M:%S&#34;)+&#39;:\n&#39;)
        self.logfile.write(&#39;\t&#39;+&#39;r2 = &#39;)
        self.logfile.write(str(self.r2))
        self.logfile.write(&#39;\n&#39;)
        self.logfile.write(&#39;\t&#39;+&#39;Parameters = &#39;)
        self.logfile.write(str(parameters))
        self.logfile.write(&#39;\n&#39;)
        self.logfile.close()


    def _residual(self,p):
        parameter = dict(p.valuesdict())
        for caso in self.casos:
            self.casos[caso].verifyFolders(self.iter,p)
            self.casos[caso].writeCase(p,self.iter)
        #if(self.thisIter != self.iter):
        z = []
        for caso in self.casos:
            t = threading.Thread(target=self._run, args=(caso,&#39;&#39;))
            t.start()
            z.append(t)
        for t in z:
           t.join()

        # #sys.exit()
        fun = dict()
        residual = dict()
        self._expToFunction()
        self.results = dict()
        totResid = []

        totResid = np.array([])
        for caso in self.casos:
            x, y = self.casos[caso].simResults(self.iter)
            if(self.iter == 1):
                self.len1[caso] = len(x)

            else:
                if(len(x) != self.len1[caso]):
                    i = self.len1[caso]
                    z = i / len(x)
                    x = interpolation.zoom(x,z)
                    y = interpolation.zoom(y,z)
            residual[caso] = -(self.expfcn[caso](x)-y)
            self.results[caso] = [x,y]
            #self.residual = residual
            #totResid.append(residual[caso])
            totResid = np.append(totResid,residual[caso])
        self._statistics(p)
        return totResid

    def _per_iteration(self,pars, iter, resid, *args, **kws):
        print(&#34; ITER &#34;, iter, [[i,pars.valuesdict()[i]] for i in pars.valuesdict()])
        self.iter = iter+3

    def optimize(self,**kwargs):
        &#39;&#39;&#39;
        Optimize.

        This function start the optimization algorithm.
        The residual is calculated from the simulation (using the external function provided for the case), and compare those results with the experimental data provided.


        kwargs:
        ----------

            kwargs for the lmfit.minimize function.
            &gt;&gt;&gt; optimize(method=&#39;basinhopping&#39;)
        &#39;&#39;&#39;
        self._updateParamList()
        self.mi = lmfit.minimize(self._residual,
                            self.p,
                            **dict(kwargs, iter_cb=self._per_iteration)
                            )
        lmfit.printfuncs.report_fit(self.mi.params, min_correl=0.5)
        print(lmfit.fit_report(self.mi))

    def _signal_handler(self,sig, frame):
        print()
        print(&#34;***********************************&#34;)
        print(&#34;***********************************&#34;)
        print()
        print(&#39;You pressed Ctrl+C!&#39;)
        print(&#34;Killing the running simulations:&#34;)
        print(self.pid)
        print()
        print(&#34;***********************************&#34;)
        print(&#34;***********************************&#34;)

        for key in self.pid:
            try:
                parent = psutil.Process(self.pid[key])
            except:
                continue
            for child in parent.children(recursive=True):  # or parent.children() for recursive=False
                try:
                    child.kill()
                except:
                    print(&#34;Child process no longer exists.&#34;)
                    continue
            try:
                parent.kill()
            except:
                print(&#34;Parent process no longer exists.&#34;)
                continue
        sys.exit(0)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="interFEBio.fit.fit.addCase"><code class="name flex">
<span>def <span class="ident">addCase</span></span>(<span>self, name, matID, modelName, subFolder, expData, simFcn)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a simulation to the fitting algorithm, including all the experimental data
and how to obtain numerical results for this xplt file.</p>
<h2 id="args">Args:</h2>
<pre><code>modelName (str): Name of the .feb model

matID (int/str): id/name of the material to be fitted in that particular .feb file

subFolder (str): Sub folder to store the simulation at each iteration.

expData (np array): Array of x,y experimental data associated with the current simulation.

simFcn (fuinction): Function that handles the result calculation of the simulation. Needs to be written in terms of the xplt class functions.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addCase(self,name,matID,modelName,subFolder,expData,simFcn):
    &#39;&#39;&#39;
    Add a simulation to the fitting algorithm, including all the experimental data
    and how to obtain numerical results for this xplt file.

    Args:
    ----------

        modelName (str): Name of the .feb model

        matID (int/str): id/name of the material to be fitted in that particular .feb file

        subFolder (str): Sub folder to store the simulation at each iteration.

        expData (np array): Array of x,y experimental data associated with the current simulation.

        simFcn (fuinction): Function that handles the result calculation of the simulation. Needs to be written in terms of the xplt class functions.

    &#39;&#39;&#39;
    self.casos[name] = _caso(modelName,matID,subFolder,expData,simFcn)</code></pre>
</details>
</dd>
<dt id="interFEBio.fit.fit.optimize"><code class="name flex">
<span>def <span class="ident">optimize</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Optimize.</p>
<p>This function start the optimization algorithm.
The residual is calculated from the simulation (using the external function provided for the case), and compare those results with the experimental data provided.</p>
<h2 id="kwargs">kwargs:</h2>
<pre><code>kwargs for the lmfit.minimize function.
&gt;&gt;&gt; optimize(method='basinhopping')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optimize(self,**kwargs):
    &#39;&#39;&#39;
    Optimize.

    This function start the optimization algorithm.
    The residual is calculated from the simulation (using the external function provided for the case), and compare those results with the experimental data provided.


    kwargs:
    ----------

        kwargs for the lmfit.minimize function.
        &gt;&gt;&gt; optimize(method=&#39;basinhopping&#39;)
    &#39;&#39;&#39;
    self._updateParamList()
    self.mi = lmfit.minimize(self._residual,
                        self.p,
                        **dict(kwargs, iter_cb=self._per_iteration)
                        )
    lmfit.printfuncs.report_fit(self.mi.params, min_correl=0.5)
    print(lmfit.fit_report(self.mi))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#todo">TODO</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="interFEBio" href="index.html">interFEBio</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="interFEBio.fit.fit" href="#interFEBio.fit.fit">fit</a></code></h4>
<ul class="">
<li><code><a title="interFEBio.fit.fit.addCase" href="#interFEBio.fit.fit.addCase">addCase</a></code></li>
<li><code><a title="interFEBio.fit.fit.optimize" href="#interFEBio.fit.fit.optimize">optimize</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>